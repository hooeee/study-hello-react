---
title: 코어 자바스크립트
date: 2022-11-21 23:52:00 +0900
category: JS
draft: false
---

## 2022-11-21-코어-자바스크립트

## 목차

## 01.데이터 타입의 종류

- 기본형
  - 원시형, primitive type
    - 숫자, 문자열, 불리언, null, undefined등
    - ES6에서 심볼 추가
- 참조형
  - reference type
  - 객체, 배열, 함수, 날짜, 정규표현식등
  - ES6에서 추가된 Map, WeakMap, Set, WeakSet등

- 둘다 복제는 한다.
  - 기본형의 경우 값이 담긴 주솟값을 바로 복제
    - 불변성을 띔
  - 참조형은 값이 담긴 주솟값들로  이루어진 묶임

## 02.데이터 타입에 관한 배경지식

### 1-2-1 메모리와 데이터

- 숫자의 경우 
  - 정수형인지 부동소수형인지 구분하지 않고,
    - 64비트, 즉 8바이트 확보
- 모든 데이터는 바이트 단위의 식별자
  - 메모리 주솟값을 통해 서로 구분하고 연결할 수 있음

### 1-2-2 식별자와 변수

- 변수
  - 변할 수 있는 수
  - 변할 수 있는 무언가(데이터)
- 식별자
  - 어떤 데이터를 식별하는 데 사용하는 이름
    - 즉, 변수명

### 04.기본형 데이터와 참조형 데이터

### 1-4-1 불변값

- 변수와 상수를 구분 짓는 것
  - 변경 가능성
- 변경 가능성의 대상은 **변수 영역 메모리**
  - 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터 재할당 할 수 있는지
- 불변성 여부를 구분시
  - 변경 가능성의 대상은 **데이터 영역 메모리**
- 변경의 경우 새로 만드는 동작을 통해서만 이뤄짐

### 1-4-2 가변값

- 기본형 데이터가 불변값이라면
- 참조형이 그럼 가변값인가?
  - 기본적인 성질은 가변값인 경우가 많음
  - 설정에 따라 변경 불가능한 경우도 있고,
    - 아예 불변값으로 할용하는 방안도 있음

### 1-4-3 변수 복사 비교

```js
var a = 10;
var b = a;

var obj1 ={ c: 10, d: 'ddd'};
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

- 결과

  ```js
  a !==b
  obj1 === obj2
  ```

  - 위의 결과가 기본형과 참조형 데이터의 가장 큰 차이

- 대부분 책에서는

  - 기본형은 값을 복사
  - 참조형은 주솟값을 복사
    - 사실은 어떤 데이터 타입이든 변수에 할당하기 위해서는 주솟값 복사해야함
      - 엄밀히 따지면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수 밖에 없음
  - 기본형은 주솟값을 복사하는 과정 한 번
    - 사실 기본형도 주솟값 참조하긴함
  - 참조형은 한 단계를 더 거치는 차이가 있음

## 05.불변 객체

### 1-5-1 불변 객체를 만드는 간단한 방법

- 불변 객체가 필요한 상항
  - 값으로 전달받은 객체에 변경을 가하더라도
  - 원본 객체는 변하지 않아야 하는 경우가 종종 발생 이때 필요

- 문제 코드

  ```js
  var user = {
  	name: 'Jeanam',
      gender: 'male'
  };
  
  var changeName = function (user, newName) {
  	var newUser = user;
      newUser.name = newName;
      return newUser;
  };
  
  var user2 = changeName(user, 'Jung');
  
  if(user != user2){
      console.log('유저 정보가 변경되었습니다.');
  }
  console.log(user.name, user2.name); // Jung Jung
  console.log(user === user2); // true
  ```

  - if문을 들어가지 않음

    ![image-20221122003708020](../../assets/img/post/2022-11-21-코어-자바스크립트/image-20221122003708020.png)

- 문제 해결 소스

  ```js
  var user = {
  	name: 'Jeanam',
      gender: 'male'
  };
  
  var changeName = function (user, newName) {
      return {
          name: newName,
          gender: user.gender
      };
  };
  
  var user2 = changeName(user, 'Jung');
  
  if(user != user2){
      console.log('유저 정보가 변경되었습니다.');
  }
  console.log(user.name, user2.name); // Jeanam Jung
  console.log(user === user2); // false
  ```

  ![image-20221122003901683](../../assets/img/post/2022-11-21-코어-자바스크립트/image-20221122003901683.png)

- 기본 정보를 복사해서 새로운 객체를 반환하는 함수

  - 얇은 복사

    ```js
    var copyObject = function (target){
        var result = {};
        for (var prop in target){
    		result[prop] = target[prop];
        }
        return result;
    }
    ```

  - copyObject이용한 객체 복사

    ```js
    var user = {
    	name: 'Jeanam',
        gender: 'male'
    };
    
    var copyObject = function (target){
        var result = {};
        for (var prop in target){
    		result[prop] = target[prop];
        }
        return result;
    }
    
    var user2 = copyObject(user);
    user2.name = 'Jung';
    
    if(user != user2){
        console.log('유저 정보가 변경되었습니다.');
    }
    console.log(user.name, user2.name); // Jeanam Jung
    console.log(user === user2); // false
    ```

    ![image-20221122004255628](../../assets/img/post/2022-11-21-코어-자바스크립트/image-20221122004255628.png)

- 여기서 user 객체 내부의 변경이 필요할 때는 무조건 

  - copyObject함수를 사용하기로 합의하고 그 규칙을 지킨다면
    - user객체가 곧 불변객체라고 할 수 있음
    - 위의 단점은 얇은 복사만 진행하는 것